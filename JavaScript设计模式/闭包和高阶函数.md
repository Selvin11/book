> 闭包和高阶函数

## 闭包

1. 定义：**当函数可以记住并访问所在的作用域(全局作用域除外)时，就产生了闭包，即使函数是在当前作用域之外执行。**

   简单来说，假设**函数A在函数B的内部进行定义了**，并且当函数A在执行时，**访问了函数B内部的变量对象**，那么B就是一个闭包。

2. 意义：阻止函数执行完毕导致的垃圾回收，保留函数中的变量对象，使得可以继续被访问，延长了变量对象的生命周期。

3. 闭包和OOP

  * 闭包的实现：

  ```javascript
  var extend = (function () {
    var value = 0
    return {
      call: function () {
        value++
        console.log(value)
      }
    }
  })()
  extend.call() // 1
  extend.call() // 2
  extend.call() // 3
  ```

  * OOP的实现

  ```javascript
  var extend = {
    value: 0,
    call: function () {
      this.value++
      console.log(this.value)
    }
  }
  extend.call() // 1
  extend.call() // 2
  extend.call() // 3
  // or
  var Extend = function () {
    this.value = 0
  }
  Extend.prototype.call = function () {
    this.value++
    console.log(this.value)
  }
  var extend = new Extend()
  extend.call() // 1
  extend.call() // 2
  extend.call() // 3
  ```

  ## 高阶函数

  1. 满足条件：函数可以作为参数传递 || 函数可以作为返回值输出

  2. 高阶函数实现AOP

    * AOP：AOP(面向切面编程)的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些 跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来之后， 再通过“动态织入”的方式掺入业务逻辑模块中。这样做的好处首先是可以保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用日志统计等功能模块。
      ```javascript
      Function.prototype.before = function (beforefn) {
        var __self = this;   保存原函数的引用
        return function () {  返回包含了原函数和新函数的"代理"函数
          beforefn.apply(this, arguments);  执行新函数，修正 this
          return __self.apply(this, arguments);  执行原函数
        }
      }
      Function.prototype.after = function (afterfn) {
        var __self = this;
        return function () {
          var ret = __self.apply(this, arguments);
          afterfn.apply(this, arguments);
          return ret;
        }
      };
      var func = function () {
        console.log(2);
      };
      func = func.before(function () {
        console.log(1);
      }).after(function () {
        console.log(3);
      });
      func();

      执行过程拆解
      1. func.before().after()为一个整体作为第一次执行，即after返回的匿名函数，此为进入的第一个函数上下文
      2. 进入func.before()上下文
      3. 进入func.after()上下文
      ```

    * currying函数柯里化

      ```javascript
      var currying = function (fn) {
        var args = [];
        return function () {
          if (arguments.length === 0) {
            return fn.apply(this, args);
          } else {
            [].push.apply(args, arguments);
            return arguments.callee;
          }
        }
      };
      var cost = (function () {
        var money = 0;
        return function () {
          for (var i = 0, l = arguments.length; i < l; i++) {
            money += arguments[i];
          }
          return money;
        }
      })();
      var cost = currying(cost);
      // 转化成 currying 函数
      cost(100);
      cost(200);
      cost(300);
      // 未真正求值 // 未真正求值 // 未真正求值
      alert(cost()); // 求值并输出:600
      ```
    * uncurrying

      ```javascript
      Function.prototype.uncurrying = function () { 
        var self = this; // this -> Array.prototype.push
        return function() {
          var obj = Array.prototype.shift.call( arguments ); // obj -> {
            length: 3,
            '0': 1,
            '1': 2,
            '2': 3
          }
          // arguments shfit 掉了第一个元素后，就只剩下4了
          return self.apply( obj, arguments );
        }
      }

      var push = Array.prototype.push.uncurrying();
      (function(){
        push(arguments, 4);
        console.log( arguments ); // 输出:[1, 2, 3, 4]
      })( 1, 2, 3 );

      ```