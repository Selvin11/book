## 命令模式

1. [命令模式的用途](#1)
2. [命令模式的例子](#2)
3. [撤销和重做](#3)

---
#### <a name="1">1. 命令模式的用途</a>

  命令模式是最简单和优雅的模式之一，命令模式中的命令(command)指的是一个执行某些特定事情的指令。

    很多时候，我们需要撤销一系列的命令。比如在一个围棋程序中，现在已经下了 10 步棋，我们需要一次性悔棋到第 5 步。在这之前，我们可以把所有执行过的下棋命令都储存在一个历史列表中，然后倒序循环来依次执行这些命令的直到循环执行到第 5 个命令为止。
  命令模式最常见的应用场景是:有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，是的请求发送者和请求接受者能够消除彼此之间的耦合关系。

---
#### <a name="2">2. 命令模式的例子</a>

  假设我们正在编写一个用户界面程序，该用户界面上至少有数十个 Button 按钮。因为项目 比较复杂，所以我们决定让某个程序员负责绘制这些按钮，而另外一些程序员则负责编写点击按 钮后的具体行为，这些行为都将被封装在对象里。

  我们很快可以找到在这里运用命令模式的理由:点击了按钮之后，必须向某些负责具体行为的对象发送请求，这些对象就是请求的接收者。但是目前并不知道接收者是什么对象，也不知道 接收者究竟会做什么。此时我们需要借助命令对象的帮助，以便解开按钮和负责具体行为对象之间的耦合。

  ```javascript
  // 定义setCommand函数，用于向按钮上安装命令
  // command对象上有执行命令的excute方法
  var setCommand = function (button, command) {
    button.onclick = function () {
      command.excute()
    }
  }
  // 各模块功能
  var MenuBar = {
    refresh: function () {
      console.log('刷新菜单目录')
    }
  }
  ...
  // 封装command对象
  var RefreshMenuBarCommand = function (receiver) {
    this.receiver = receiver
  }
  RefreshMenuBarCommand.prototype.excute = function () {
    this.receiver.refresh()
  }
  // 调用
  var refreshMenuBarCommand = new RefreshMenuBarCommand(MenuBar)
  setCommand(refreshMenuBarCommand)
  ```

  可能看到上面代码，感觉command对象有点复杂化了，可以将命令用回调函数传入setCommand。

  JavaScript 作为将函数作为一等对象的语言，跟策略模式一样，命令模式也早已融入到了 JavaScript 语言之中。运算块不一定要封装在 command.execute 方法中，也可以封装在普通函数中。 函数作为一等对象，本身就可以被四处传递。即使我们依然需要请求“接收者”，那也未必使用面向对象的方式，闭包可以完成同样的功能。


  
---
#### <a name="3">3. 撤销和重做</a>

  命令模式的作用不仅是封装运算块，而且可以很方便地给命令对象增加撤销操作。就像订餐时客人可以通过电话来取消订单一样。

  撤销是命令模式里一个非常有用的功能，试想一下开发一个围棋程序的时候，我们把每一步棋子的变化都封装成命令，则可以轻而易举地实现悔棋功能。同样，撤销命令还可以用于实现文 本编辑器的 Ctrl+Z 功能。

  很多时候，我们需要撤销一系列的命令。比如在一个围棋程序中，现在已经下了 10 步棋，我们需要一次性悔棋到第 5 步。在这之前，我们可以把所有执行过的下棋命令都储存在一个历史列表中，然后倒序循环来依次执行这些命令的undo 操作，直到循环执行到第 5 个命令为止。
  
  然而，在某些情况下无法顺利地利用 undo 操作让对象回到 execute 之前的状态。比如在一个 Canvas 画图的程序中，画布上有一些点，我们在这些点之间画了 N 条曲线把这些点相互连接起 来，当然这是用命令模式来实现的。但是我们却很难为这里的命令对象定义一个擦除某条曲线的 undo 操作，因为在 Canvas 画图中，擦除一条线相对不容易实现。
  
  这时候最好的办法是先清除画布，然后把**刚才执行过的命令全部重新执行一遍，这一点同样可以利用一个历史列表堆栈办到。记录命令日志，然后重复执行它们，这是逆转不可逆命令的一个好办法**。


  历史回退 || 历史重演