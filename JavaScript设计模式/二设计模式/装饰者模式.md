## 装饰者模式

1. [模拟传统面向对象语言的装饰者模式](#1)



装饰者模式可以动态地 给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他对象。

这种给对象动态地增加职责的方式称为装饰者(decorator)模式。装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责。跟继承相比，装饰者是一种更轻便灵活的做法，这是一种“即用即付”的方式。

---
#### <a name="1">1. 模拟传统面向对象语言的装饰者模式</a>

  在Javascript中尽管随意一个声明之后的对象，都可以改变对象属性对应的值，但这和传统定义的装饰者模式并不一样。

  ```javascript
  var Plane = function(){}
   Plane.prototype.fire = function(){ 
     console.log( '发射普通子弹' );
  }
  // 接下来增加两个装饰类，分别是导弹和原子弹:
  var MissileDecorator = function( plane ){ 
    this.plane = plane;
  }
  MissileDecorator.prototype.fire = function(){ 
    this.plane.fire();
    console.log( '发射导弹' );
  }
  var AtomDecorator = function( plane ){ 
    this.plane = plane;
  }
  AtomDecorator.prototype.fire = function(){ 
    this.plane.fire();
    console.log( '发射原子弹' );
  }
  ```
  这种给对象动态增加职责的方式，并没有真正地改动对象自身，而是将对象放入另一个对象之中，这些对象以一条链的方式进行引用，形成一个聚合对象。这些对象都拥有相同的接口(fire 方法)，当请求达到链中的某个对象时，这个对象会执行自身的操作，随后把请求转发给链中的下一个对象。

  因为装饰者对象和它所装饰的对象拥有一致的接口，所以它们对使用该对象的客户来说是透明的，被装饰的对象也并不需要了解它曾经被装饰过，这种透明性使得我们可以递归地嵌套任意多个装饰者对象。
