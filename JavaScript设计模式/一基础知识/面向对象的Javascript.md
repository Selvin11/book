## 面向对象的Javascript
 
1. [动态类型语言和鸭子类型](#1)
2. [多态](#2)
3. [封装](#3)
4. [原型模式和基于原型继承的JavaScript对象系统](#4)



#### <a name="#1">1. 动态类型语言和鸭子类型</a>

  * Javascript没有提供传统面向对象语言中的类式继承，而是通过原型(prototype)委托的方式来实现的。

  * 编程语言按照数据类型大致分为静态语言（需声明变量类型，编译时便确定了变量类型），动态语言（无需声明变量类型，在代码执行过程中，才会有变量类型）。
  
  * 鸭子类型：只关注对象的行为结果，不关注当前对象是谁等。

    在动态类型语言的面向对象设计中，鸭子类型的概念至关重要。利用鸭子类型的思想，我们不必借助超类型的帮助，就能轻松地在动态类型语言中实现一个原则:“面向接口编程，而不是 面向实现编程”。



#### <a name="#2">2. 多态</a>

  * 多态：同一操作作用于不同对象上，产生了不同的解释和不同的结果。

  * 实现：**将“做什么”和“谁去做以及怎样做”分离开来**

      ```javascript
      var makeSound = function( animal ){ animal.sound();};
      var Duck = function(){}
      Duck.prototype.sound = function(){ console.log( '嘎嘎嘎' );
      };
      var Chicken = function(){}
      Chicken.prototype.sound = function(){ console.log( '咯咯咯' );
      };
      makeSound( new Duck() ); // 嘎嘎嘎
      makeSound( new Chicken() ); // 咯咯咯
      ```

  * 多态在面向对象程序设计中的作用：通过把**过程化的条件分支语句**转化为**对象的多态性**，从而消除这些条件分支语句

  * 设计模式与多态：

    * 命令模式：请求封装在命令对象中，将命令的调用者和使用者解耦
    * 组合模式：对**组合对象**和**叶节点对象**发出同一个消息时，会各自执行自己的任务，组合对象会将消息继续转发给下面的叶节点对象，然后继续执行
    * 策略模式：上下文没有执行算法的能力，执行算法都委托给了策略对象，各自负责对应的算法执行，然后返回计算结果。



####<a name="#3">3. 封装</a>

  * 目的：将内部的数据（私有变量，公共方法等）、实现、类型、**变化**（找到变化并封装之）等细节隐藏，只暴露API接口即可

  * 封装实现：从封装实现细节来讲，封装使得对象内部的变化对其他对象而言是透明的，也就是不可见的。 对象对它自己的行为负责。其他对象或者用户都不关心它的内部实现。封装使得对象之间的耦合变松散，对象之间只通过暴露的 API 接口来通信。当我们修改一个对象时，可以随意地修改它的内部实现，只要对外的接口没有变化，就不会影响到程序的其他功能。

  * 封装变化：从设计模式的角度出发，封装在更重要的层面体现为封装变化。
    
    通过封装变化的方式，把系统中稳定不变的部分和容易变化的部分隔离开来，在系统的演变过程中，我们只需要替换那些容易变化的部分，如果这些部分是已经封装好的，替换起来也相对容易。这可以最大程度地保证程序的稳定性和可扩展性。

  * 理解：当我们想办法把程序中变化的部分封装好之后，剩下的即是稳定而可复用的部分了。

    ​

####<a name="#4">4. 封装原型模式和基于原型继承的JavaScript对象系统</a>

  * 原型模式不仅是一种设计模式，也是一种**编程范型**

  * 使用克隆的原型模式：如自带的`Object.create`方法

  * **克隆是创建对象的手段**，A克隆Object，B克隆A，Object是A的原型，A是B的原型，从而形成了原型链（JavaScript中通过new或直接赋值，然后由引擎内部克隆原型对象）

  * **原型编程范型的基本规则**

    * 所有的数据都是对象

    * 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它

    * 对象会记住它的原型

    * 当对象无法响应某个请求时，会把该请求委托给它自己的原型

  * 通过原型编程范型理解new运算符克隆原型对象的原理

      ```javascript
      function Person (name) {
        this.name = name
      }
      var a = new Person('Selvin')
      1. 创建空对象，var obj = new Object()
      2. 用构造器Constructor记录new后面衔接的对象Person
      3. 将构造器的原型赋给obj的原型（2，3步骤就是为了记住对象的原型）
      4. 返回obj，完成对象克隆
      ```