## 第一部分 基础知识

1. [面向对象的Javascript](#1)
  * [动态类型语言和鸭子类型](#1.1)
  * [多态](#1.2)
  * [封装](#1.3)
  * [原型模式和基于原型继承的JavaScript对象系统](#1.4)

2. [this、call和apply](#2)
  * [this](#2.1)
  * [call和apply](#2.2)

3. [闭包和高阶函数](#3)
  * [闭包](#3.1)

   ​

#### <a name="1">1. 面向对象的Javascript</a>


  <a name="#1.1">1.1. 动态类型语言和鸭子类型</a>

  * Javascript没有提供传统面向对象语言中的类式继承，而是通过原型(prototype)委托的方式来实现的。

  * 编程语言按照数据类型大致分为静态语言（需声明变量类型，编译时便确定了变量类型），动态语言（无需声明变量类型，在代码执行过程中，才会有变量类型）。
  
  * 鸭子类型：只关注对象的行为结果，不关注当前对象是谁等。

    在动态类型语言的面向对象设计中，鸭子类型的概念至关重要。利用鸭子类型的思想，我们不必借助超类型的帮助，就能轻松地在动态类型语言中实现一个原则:“面向接口编程，而不是 面向实现编程”。



  <a name="#1.2">1.2. 多态</a>

  * 多态：同一操作作用于不同对象上，产生了不同的解释和不同的结果。

  * 实现：**将“做什么”和“谁去做以及怎样做”分离开来**

      ```javascript
      var makeSound = function( animal ){ animal.sound();};
      var Duck = function(){}
      Duck.prototype.sound = function(){ console.log( '嘎嘎嘎' );
      };
      var Chicken = function(){}
      Chicken.prototype.sound = function(){ console.log( '咯咯咯' );
      };
      makeSound( new Duck() ); // 嘎嘎嘎
      makeSound( new Chicken() ); // 咯咯咯
      ```

  * 多态在面向对象程序设计中的作用：通过把**过程化的条件分支语句**转化为**对象的多态性**，从而消除这些条件分支语句

  * 设计模式与多态：

    * 命令模式：请求封装在命令对象中，将命令的调用者和使用者解耦
    * 组合模式：对**组合对象**和**叶节点对象**发出同一个消息时，会各自执行自己的任务，组合对象会将消息继续转发给下面的叶节点对象，然后继续执行
    * 策略模式：上下文没有执行算法的能力，执行算法都委托给了策略对象，各自负责对应的算法执行，然后返回计算结果。



  <a name="#1.3">1.3. 封装</a>

  * 目的：将内部的数据（私有变量，公共方法等）、实现、类型、**变化**（找到变化并封装之）等细节隐藏，只暴露API接口即可

  * 封装实现：从封装实现细节来讲，封装使得对象内部的变化对其他对象而言是透明的，也就是不可见的。 对象对它自己的行为负责。其他对象或者用户都不关心它的内部实现。封装使得对象之间的耦合变松散，对象之间只通过暴露的 API 接口来通信。当我们修改一个对象时，可以随意地修改它的内部实现，只要对外的接口没有变化，就不会影响到程序的其他功能。

  * 封装变化：从设计模式的角度出发，封装在更重要的层面体现为封装变化。
    
    通过封装变化的方式，把系统中稳定不变的部分和容易变化的部分隔离开来，在系统的演变过程中，我们只需要替换那些容易变化的部分，如果这些部分是已经封装好的，替换起来也相对容易。这可以最大程度地保证程序的稳定性和可扩展性。

  * 理解：当我们想办法把程序中变化的部分封装好之后，剩下的即是稳定而可复用的部分了。

    ​

  <a name="#1.4">1.4. 封装原型模式和基于原型继承的JavaScript对象系统</a>

  * 原型模式不仅是一种设计模式，也是一种**编程范型**

  * 使用克隆的原型模式：如自带的`Object.create`方法

  * **克隆是创建对象的手段**，A克隆Object，B克隆A，Object是A的原型，A是B的原型，从而形成了原型链（JavaScript中通过new或直接赋值，然后由引擎内部克隆原型对象）

  * **原型编程范型的基本规则**

    * 所有的数据都是对象

    * 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它

    * 对象会记住它的原型

    * 当对象无法响应某个请求时，会把该请求委托给它自己的原型

  * 通过原型编程范型理解new运算符克隆原型对象的原理

    ```javascript
    function Person (name) {
      this.name = name
    }
    var a = new Person('Selvin')
    1. 创建空对象，var obj = new Object()
    2. 用构造器Constructor记录new后面衔接的对象Person
    3. 将构造器的原型赋给obj的原型（2，3步骤就是为了记住对象的原型）
    4. 返回obj，完成对象克隆
    ```




#### <a name="#2">2. this、call和apply</a>

  <a name="#2.1">2.1. this</a>

  JavaScript 的 this 总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。

  * this的指向：作为对象方法／普通函数／构造器／call或apply调用

    **如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined**。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。

  * this的丢失：this所属的函数没有被一个对象（非全局对象）所拥有，指向undefined

  ​<a name="#2.2">2.2. call和apply</a>

  * apply：apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下 标的集合，这个集合可以为数组，也可以为类数组

  * call：call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向， 从第二个参数开始往后，每个参数被依次传入函数

  * call和apply的用途：

    1. 改变this指向
    2. Function.prototype.bind 
			```javascript
			// 模拟bind实现
			Function.prototype.bind = function(context) {
				var self = this
				return function () {
					return self.apply(context, arguments)
				}
			}
			```
    3. 借用其它对象的方法
			函数的参数列表arguments是一个类数组对象，如需向其添加元素，需要借用Array对象的push方法
			```javascript
			(function(){
				Array.prototype.push.call(arguments,3)
				console.log(arguments) // 输出[1,2,3]
			})(1,2)
			```

#### <a name="#3">3. 闭包和高阶函数</a>

  <a name="3.1">闭包</a>

  闭包的形成与变量的作用域以及变量的生存周期密切相关。

  * 定义：**当函数可以记住并访问所在的作用域(全局作用域除外)时，就产生了闭包，即使函数是在当前作用域之外执行**。简单来说，假设**函数A在函数B的内部进行定义了**，并且当函数A在执行时，**访问了函数B内部的变量对象**，那么B就是一个闭包。

  * 意义：阻止函数执行完毕导致的垃圾回收，保留函数中的变量对象，使得可以继续被访问，延长了变量对象的生命周期。

  * 变量的作用域：就是指变量的有效范围，我们最常谈到的是在函数中声明的变量作用域。

    在 JavaScript 中，函数可以用来创造函数作用域。此时的函数像一层半透明的玻璃，在函数 里面可以看到外面的变量，而在函数外面则无法看到函数里面的变量。这是因为当在函数中搜索 一个变量的时候，如果该函数内并没有声明这个变量，那么此次搜索的过程会随着代码执行环境 创建的作用域链往外层逐层搜索，一直搜索到全局对象为止。变量的搜索是从内到外而非从外到 内的。

  * 变量的生存周期：对于全局变量来说，全局变量的生存周期当然是永久的，除非我们主动销毁这个全局变量。而对于在函数内用 var 关键字声明的局部变量来说，当退出函数时，这些局部变量即失去了它们的价值，它们都会随着函数调用的结束而被销毁。
​			
  * 闭包的更多作用：

    1. 封装变量：闭包可以帮助把一些不需要暴露在全局的变量封装成“私有变量”。 
​	



​	
