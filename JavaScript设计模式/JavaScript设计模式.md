1. [动态类型语言和鸭子类型](#1)

2. [多态](#2)

3. [封装](#3)

4. [原型模式和基于原型继承的JavaScript对象系统](#4)

5. [this/call/apply](#5)

   ​

<h3 id="#1">1. 动态类型语言和鸭子类型</h3>

* Javascript没有提供传统面向对象语言中的类式继承，而是通过原型(prototype)委托的方式来实现的。
* 编程语言按照数据类型大致分为静态语言（需声明变量类型，编译时便确定了变量类型），动态语言（无需声明变量类型，在代码执行过程中，才会有变量类型）。
* 鸭子类型：只要最后的结果满足了，其它是没有关系的，只关注对象的行为结果，不关注当前对象是谁等。



<h3 id="#2">2. 多态</h3>

* 多态：同一操作作用于不同对象上，产生了不同的解释和不同的结果。

* 实现：**将“做什么”和“谁去做以及怎样做”分离开来**

  ```javascript
  var makeSound = function( animal ){ animal.sound();};
  var Duck = function(){}
  Duck.prototype.sound = function(){ console.log( '嘎嘎嘎' );
  };
  var Chicken = function(){}
  Chicken.prototype.sound = function(){ console.log( '咯咯咯' );
  };
  makeSound( new Duck() ); // 嘎嘎嘎
  makeSound( new Chicken() ); // 咯咯咯
  ```

* 作用：通过把**过程化的条件分支语句**转化为**对象的多态性**，从而消除这些条件分支语句

* 设计模式与多态：
  * 命令模式：请求封装在命令对象中，将命令的调用者和使用者解耦
  * 组合模式：对**组合对象**和**叶节点对象**发出同一个消息时，会各自执行自己的任务，组合对象会将消息继续转发给下面的叶节点对象，然后继续执行
  * 策略模式：上下文没有执行算法的能力，执行算法都委托给了策略对象，各自负责对应的算法执行，然后返回计算结果。



<h3 id="#3">3. 封装</h3>

* 目的：将内部的数据（私有变量，公共方法等）、实现、类型、**变化**（找到变化并封装之）等细节隐藏，只暴露API接口即可

* 理解：当我们想办法把程序中变化的部分封装好之后，剩下的即是稳定而可复
  用的部分了。

  ​

<h3 id="#4">4.  封装原型模式和基于原型继承的JavaScript对象系统</h3>

* 使用克隆的原型模式：如自带的`Object.create`方法

* **克隆是创建对象的手段**，A克隆Object，B克隆A，Object是A的原型，A是B的原型，从而形成了原型链（JavaScript中通过new或直接赋值，然后由引擎内部克隆原型对象）

* 原型模式不仅是一种设计模式，也是一种**编程范型**

* **原型编程范型的基本规则**

  * 所有的数据都是对象

  * 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它

  * 对象会记住它的原型
  * 当对象无法响应某个请求时，会把该请求委托给它自己的原型

* 通过原型编程范型理解new运算符克隆原型对象的原理

  ```javascript
  function Person (name) {
    this.name = name
  }
  var a = new Person('Selvin')
  1. 创建空对象，var obj = new Object()
  2. 用构造器Constructor记录new后面衔接的对象Person
  3. 将构造器的原型赋给obj的原型（2，3步骤就是为了记住对象的原型）
  4. 返回obj，完成对象克隆
  ```




<h3 id="#5">5.  this/call/apply</h3>

* this

  * this的指向：作为对象方法／普通函数／构造器／call或apply调用

    **如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined**。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。

  * this的丢失：this所属的函数没有被一个对象（非全局对象）所拥有，指向undefined

  ​

  ​

​			
​		
​	



​	